#!/usr/bin/perl

=head1 NAME

pristine-gz - regenerate pristine gz files

=head1 SYNOPSIS

B<pristine-gz> [-vd] gengz delta file
B<pristine-gz> [-vd] gendelta file.gz delta

=head1 DESCRIPTION

This is a complement to the pristine-tar(1) command. Normally you don't
need to run it by hand, since pristine-tar calls it as necessary to handle
.tar.gz files.

pristine-gz gendelta takes the specified gz file, and generates a
small binary delta file that can later be used by pristine-gz gengz
to recreate the original file.

pristine-gz gengz takes the specified delta file, and compresses
the specified input file (which must be identical to the contents
of the original gz file). The resulting gz file will be identical to the
original gz file.

The approach used to regenerate the original gz file is to figure out how
it was produced -- what compression level was used, whether it was built
with gzip(1) or with bsd-gzip(1), whether the --rsyncable option was used,
etc, and to reproduce this build environment when regenerating the gz.
In a few cases post-build fixups are also done to ensure that the gz is
identical to the original.

This approach will work in the vast majority of cases. If it doesn't work,
no delta will be generated. One example of a case it cannot currently
support is a gz file that has been produced by appending together multiple
gz files.

=head1 OPTIONS

=over 4

=item -v

Verbose mode, show each command that is run.

=item -d

Debug mode.

=head1 AUTHOR

Joey Hess <joeyh@debian.org>,
Faidon Liambotis <paravoid@debian.org>

Licensed under the GPL, version 2.

=cut

use warnings;
use strict;
use File::Temp;
use Getopt::Long;
use File::Basename qw/basename/;

use constant GZIP_DEBUG		 => 1;

# magic identification
use constant GZIP_ID1		 => 0x1F;
use constant GZIP_ID2		 => 0x8B;

# compression methods, 0x00-0x07 are reserved
use constant GZIP_METHOD_DEFLATE => 0x08;

# flags
use constant {
	GZIP_FLAG_FTEXT		 => 0,
	GZIP_FLAG_FHCRC		 => 1,
	GZIP_FLAG_FEXTRA	 => 2,
	GZIP_FLAG_FNAME		 => 3,
	GZIP_FLAG_FCOMMENT	 => 4,
	# the rest are reserved
};
# compression level
use constant {
	GZIP_COMPRESSION_NORMAL	 => 0,
	GZIP_COMPRESSION_BEST	 => 2,
	GZIP_COMPRESSION_FAST	 => 4,
};
# operating systems
use constant {
	GZIP_OS_MSDOS		 => 0,
	GZIP_OS_AMIGA		 => 1,
	GZIP_OS_VMS		 => 2,
	GZIP_OS_UNIX		 => 3,
	GZIP_OS_VMCMS		 => 4,
	GZIP_OS_ATARI		 => 5,
	GZIP_OS_HPFS		 => 6,
	GZIP_OS_MACINTOSH	 => 7,
	GZIP_OS_ZSYSTEM		 => 8,
	GZIP_OS_CPM		 => 9,
	GZIP_OS_TOPS		 => 10,
	GZIP_OS_NTFS		 => 11,
	GZIP_OS_QDOS		 => 12,
	GZIP_OS_RISCOS		 => 13,
	GZIP_OS_UNKNOWN		 => 255,
};

my $verbose=0;
my $debug=0;

sub usage {
	print STDERR "Usage: pristine-gz [-v] gengz delta file\n";
	print STDERR "       pristine-gz [-v] gendelta file.gz delta\n";
}

sub debug {
	print "debug: @_\n" if $debug;
}

sub vprint {
	print "pristine-gz: @_\n" if $verbose;
}

sub doit {
	vprint(@_);
	if (system(@_) != 0) {
		die "command failed: @_\n";
	}
}

sub tempdir {
	return File::Temp::tempdir("pristine-gz.XXXXXXXXXX",
		TMPDIR => 1, CLEANUP => 1);
}

sub readgzip {
	my $filename = shift;
	my $chars;

	open(GZIP, "< $filename")
		or die("Could not open '$filename' for reading: $!\n");

	if (read(GZIP, $chars, 10) != 10) {
		die("Unable to read from input\n");
	}

	my ($id1, $id2, $method, $flags, $timestamp, $level, $os, $name)
		= (unpack("CCCb8VCC", $chars), '');

	if ($id1 != GZIP_ID1 || $id2 != GZIP_ID2 || $method != GZIP_METHOD_DEFLATE) {
		die("This is not a valid GZip archive.\n");
	}
	my @flags = split(//, $flags);
	
	if ($flags[GZIP_FLAG_FNAME]) {
		# read a null-terminated string
		$name .= $chars
			while (read(GZIP, $chars, 1) == 1 && ord($chars) != 0);
	}
	close(GZIP);

	return (\@flags, $timestamp, $level, $os, $name);
}

sub predictgzipargs {
	my ($flags, $timestamp, $level) = @_;
	my @flags = @$flags;

	my @args;
	unless ($flags[GZIP_FLAG_FNAME]) {
		push @args, '-n';
		push @args, '-M' if $timestamp;
	} else { 
		push @args, '-m'
			unless($timestamp);
	}
	
	if ($level == GZIP_COMPRESSION_BEST) {
		push @args, '-9'
	} elsif ($level == GZIP_COMPRESSION_FAST) {
		push @args, '-1'
	}

	return @args;
}

sub comparefiles {
	my ($old, $new) = (shift, shift);
	system('cmp', '-s', $old, $new);

	if ($? == -1 || $? & 127) {
		die("Failed to execute cmp: $!\n");
	}

	return $? >> 8;
}

sub testvariant {
	my ($old, $new, $origname, @args) = @_;

	# Unzip attempt of the previous run (or the original on the first run)
	doit('gunzip', '-N', $new);
	if (-e $new) {
		die "gunzip failed, aborting";
	}
	elsif ($origname && -e $origname) {
		# original new because we passed -N to gunzip
		$new = $origname;
	}
	else {
		$new =~ s/\.gz$//;
		unless (-e $new) {
			die("gunzip succeded but I can't find the new file");
		}
	}

	# try gzipping with the arguments passed
	doit('zgz', @args, $new);
	$new .= '.gz';
	unless (-e $new) {
		die("zgz failed, aborting");
	}

	# and compare the generated with the original
	return !comparefiles($old, $new);
}

sub reproducegz {
	my ($wd, $orig, $new) = (shift, shift, shift);

	# read fields from gzip headers
	my ($flags, $timestamp, $level, $os, $name) = readgzip($new);
	debug("flags: [".join(", ", @$flags).
		"] timestamp: $timestamp level: $level os: $os name: $name");

	# try to guess the gzip arguments that are needed by the header
	# information
	my @args = predictgzipargs($flags, $timestamp, $level);

	if ($name !~ /\//) {
		if ($name) {
			$name = "$wd/$name";
			move($new, "$name.gz");
			doit("mv", "-f", $new, "$name.gz");
			$new = "$name.gz";
		}
		if ($os == GZIP_OS_UNIX) {
			# for 98% of the cases the simple heuristic above works
			testvariant($orig, $new, $name, '--gnu', @args)
				&& return $name, $timestamp, '--gnu', @args;

			# some .gz are created using --rsyncable
			# it is a Debian-specific option not very popular
			testvariant($orig, $new, $name, '--gnu', @args, '--rsyncable')
				&& return $name, $timestamp, '--gnu', @args, '--rsyncable';
		}
	}
	else {
		push @args, "--original-name", $name;
		$name = basename($name);
		$name = "$wd/$name";
		doit("mv", "-f", $new, "$name.gz");
		$new = "$name.gz";
	}

	# Windows' NTFS gzip implementation; quirk is really really evil
	if ($os == GZIP_OS_NTFS) {
		testvariant($orig, $new, $name, @args, '--quirk', 'ntfs')
			&& return $name, $timestamp, @args, '--quirk', 'ntfs';
	}

	# set the Operating System flag to the one found in the original
	# archive
	push @args, ("--osflag", $os) if $os != GZIP_OS_UNIX;

	# many of the .gz out there are created using the BSD version of
	# gzip which is using the zlib library; try with our version of
	# bsd-gzip with added support for the undocumented GNU gzip options
	# -m and -M
	testvariant($orig, $new, $name, @args)
		&& return $name, $timestamp, @args;
	
	# apparently, there is an old version of bsd-gzip (or a similar tool
	# based on zlib) that creates gz using maximum compression (-9) but
	# does not indicate so in the headers. surprisingly, there are many
	# .gz out there.
	testvariant($orig, $new, $name, @args, '--quirk', 'buggy-bsd')
		&& return $name. $timestamp, @args, '--quirk', 'buggy-bsd';

	print STDERR("pristine-gz failed to reproduce build of $orig\n");
	print STDERR("(Please file a bug report.)\n");
	exit 1;
}

sub gengz {
	my $delta=shift;
	my $file=shift;

	my $tempdir=tempdir();
	
	doit("tar", "xf", File::Spec->rel2abs($delta), "-C", $tempdir);
	if (! -e "$tempdir/type") {
		die "failed to gengz delta $delta\n";
	}

	open (IN, "$tempdir/version") || die "delta lacks version number ($!)";
	my $version=<IN>;
	if ($version >= 2) {
		die "delta is version $version, not supported\n";
	}
	close IN;
	if (open (IN, "$tempdir/type")) {
		my $type=<IN>;
		chomp $type;
		if ($type ne "gz") {
			die "delta is for a $type, not a gz\n";
		}
		close IN;
	}

	
	open (IN, "$tempdir/params") || die "delta lacks params file ($!)";
	my $params=<IN>;
	chomp $params;
	my @params=split(' ', $params);
	while (@params) {
		$_=shift @params;
		next if /^(--gnu|--rsyncable|-[nmM1-9])$/;
		if (/^(--original-name|--quirk|--osflag)$/) {
			shift @params;
		}
		die "paranoia check failed on params file from delta ($params)";
	}
	@params=split(' ', $params);
	close IN;
	open (IN, "$tempdir/filename") || die "delta lacks filename file ($!)";
	my $filename=<IN>;
	chomp $filename;
	if ($filename =~ /\//) {
		die "paranoia check failed on filename field from delta ($filename)";
	}
	if (! length $filename) {
		$filename="input";
	}
	close IN;
	open (IN, "$tempdir/timestamp") || die "delta lacks timestamp file ($!)";
	my $timestamp=<IN>;
	chomp $timestamp;
	close IN;

	doit("cp", $file, "$tempdir/$filename");
	utime($timestamp, $timestamp, "$tempdir/$filename") ||
		die "utime: $!";
	doit("zgz", @params, "-f", "$tempdir/$filename");
	doit("mv", "-f", "$tempdir/$filename.gz", "$file.gz");
	doit("rm", "-f", $file);
}

sub gendelta {
	my $gzfile=shift;
	my $delta=shift;

	my $tempdir=tempdir();
	my @files=qw(version type params filename timestamp);

	doit("cp", $gzfile, "$tempdir/test.gz");
	my ($filename, $timestamp, @params)=
		reproducegz($tempdir, $gzfile, "$tempdir/test.gz");

	open(OUT, ">", "$tempdir/version") || die "$!";
	print OUT "1.1\n";
	close OUT;
	open(OUT, ">", "$tempdir/type") || die "$!";
	print OUT "gz\n";
	close OUT;
	open(OUT, ">", "$tempdir/params") || die "$!";
	print OUT "@params\n";
	close OUT;
	open(OUT, ">", "$tempdir/filename") || die "$!";
	print OUT "$filename\n";
	close OUT;
	open(OUT, ">", "$tempdir/timestamp") || die "$!";
	print OUT "$timestamp\n";
	close OUT;

	doit("tar", "czf", $delta, "-C", $tempdir, @files);
}

Getopt::Long::Configure("bundling");
if (! GetOptions("v|verbose!" => \$verbose, "d|debug!" => \$debug) || @ARGV != 3) {
	usage();
	exit 1;
}

my $command=shift;
if ($command eq 'gengz') {
	gengz(@ARGV);
}
elsif ($command eq 'gendelta') {
	gendelta(@ARGV);
}
else {
	print STDERR "Unknown subcommand \"$command\"\n";
	usage();
	exit 1;
}
