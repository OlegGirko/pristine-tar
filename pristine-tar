#!/usr/bin/perl

=head1 NAME

pristine-tar - regenerate pristine tarballs

=head1 SYNOPSIS

B<pristine-tar> [-vdk] gentar delta tarball
B<pristine-tar> [-vdk] gendelta tarball delta

=head1 DESCRIPTION

pristine-tar gendelta takes the specified upstream tarball, and generates a
small binary delta file that can later be used by pristine-tar gentar
to recreate the tarball.

pristine-tar gentar takes the specified delta file, and the files in the
current directory, which must have identical content to those in the
upstream tarball, and uses these to regenerate the pristine upstream
tarball.

This is useful when maintaining a Debian package in revision control, as
you can check the delta file into revision control, tag the upstream
release in revision control, and later gentar the upstream tarball from
revison control.

pristine-tar supports compressed tarballs, calling out to pristine-gz(1)
to produce the pristine gzip files.

=head1 OPTIONS

=over 4

=item -v

Verbose mode, show each command that is run.

=item -d

Debug mode.

=item -k

Don't clean up the temporary directory on exit.

=head1 AUTHOR

Joey Hess <joeyh@debian.org>

Licensed under the GPL, version 2 or above.

=cut

use warnings;
use strict;
use File::Temp;
use File::Path;
use Getopt::Long;

# magic identification
use constant GZIP_ID1            => 0x1F;
use constant GZIP_ID2            => 0x8B;

# compression methods, 0x00-0x07 are reserved
use constant GZIP_METHOD_DEFLATE => 0x08;

my $verbose=0;
my $debug=0;
my $keep=0;
	
# Force locale to C since tar may output utf-8 filenames differently
# depending on the locale.
$ENV{LANG}='C';

sub usage {
	print STDERR "Usage: pristine-tar [-vdk] gentar delta tarball\n";
	print STDERR "       pristine-tar [-vdk] gendelta tarball delta\n";
}

sub debug {
	print "pristine-tar: @_\n" if $debug;
}

sub vprint {
	print "pristine-tar: @_\n" if $verbose;
}

sub doit {
	vprint(@_);
	if (system(@_) != 0) {
		die "command failed: @_\n";
	}
}

sub tempdir {
	return File::Temp::tempdir("pristine-tar.XXXXXXXXXX",
		TMPDIR => 1, CLEANUP => !$keep);
}

sub gentarball {
	my $tempdir=shift;
	my $source=shift;
	my $clobber_source=shift;
	
	my @manifest;
	open (IN, "$tempdir/manifest") || die "$tempdir/manifest: $!";
	while (<IN>) {
		chomp;
		push @manifest, $_;
	}
	close IN;

	# The manifest and source should have the same filenames,
	# but the manifest probably has all the files under a common
	# subdirectory. Check if it does.
	# XXX currently only zero or one subdirectory level is supported
	my $subdir="";
	foreach my $file (@manifest) {
		if ($file=~m!^(/?[^/]+)/!) {
			if (length $subdir && $subdir ne $1) {
				last;
			}
			elsif (! length $subdir) {
				$subdir=$1;
			}
		}
		else {
			debug("found file not in subdir: $file");
			$subdir="";
			last;
		}
	}

	if (length $subdir) {
		debug("subdir is $subdir");
		doit("mkdir", "$tempdir/workdir");
		$subdir="/$subdir";
	}
	else {
		debug("tarball does not unpack into a subdir");
	}

	if (! $clobber_source) {
		doit("cp", "-a", $source, "$tempdir/workdir$subdir");
	}
	else {
		doit("mv", $source, "$tempdir/workdir$subdir");
	}

	# It's important that this create an identical tarball each time
	# for a given set of input files. So don't include file metadata
	# in the tarball, since it can easily vary.
	my $full_sweep=0;
	foreach my $file (@manifest) {
		if (-l "$tempdir/workdir/$file") {
			# Can't set timestamp of a symlink, so
			# replace the symlink with an empty file.
			unlink("$tempdir/workdir/$file") || die "unlink: $!";
			open(OUT, ">", "$tempdir/workdir/$file") || die "open: $!";
			close OUT;
		}
		elsif (! -e "$tempdir/workdir/$file") {
			debug("$file is listed in the manifest but may not be present in the source directory");
			$full_sweep=1;
		}
		
		if (-d "$tempdir/workdir/$file" && (-u _ || -g _ || -k _)) {
			# tar behaves weirdly for some special modes
			# and ignores --mode, so clear them.
			debug("chmod $file");
			chmod(0755, "$tempdir/workdir/$file") ||
				die "chmod: $!";
		}
		utime 0, 0, "$tempdir/workdir/$file" || die "utime: $!";
	}
	
	# If some files couldn't be matched up with the manifest,
	# it's possible they do exist, but just with names that make sense
	# to tar, but not to this program. To work around this and make sure
	# such files have their metadata tweaked, by doing a full sweep of
	# the tree.
	if ($full_sweep) {
		debug("doing full tree sweep to catch missing files");
		use File::Find;
		find(sub {
			if (-l $_) {
				unlink($_) || die "unlink: $!";
				open(OUT, ">", $_) || die "open: $!";
				close OUT;
			}
			if (-d $_ && (-u _ || -g _ || -k _)) {
				chmod(0755, $_) ||
					die "chmod: $!";
			}
			utime 0, 0, $_ || die "utime: $!";
		}, "$tempdir/workdir");
	}

	doit("tar", "cf", "$tempdir/gentarball", "--owner", 0, "--group", 0, 
		"--numeric-owner", "-C", "$tempdir/workdir",
		"--no-recursion", "--mode", "0644", 
		"--files-from", "$tempdir/manifest"); 
}

sub gentar {
	my $delta=shift;
	my $tarball=shift;

	my $tempdir=tempdir();
	
	doit("tar", "xf", File::Spec->rel2abs($delta), "-C", $tempdir);
	if (! -e "$tempdir/type") {
		die "failed to gentar delta $delta\n";
	}

	open (IN, "$tempdir/version") || die "delta lacks version number ($!)";
	my $version=<IN>;
	if ($version >= 3 || $version < 2) {
		die "delta is version $version, not supported\n";
	}
	close IN;
	if (open (IN, "$tempdir/type")) {
		my $type=<IN>;
		chomp $type;
		if ($type ne "tar") {
			die "delta is for a $type, not a tar\n";
		}
		close IN;
	}

	gentarball($tempdir, ".", 0);
	my $out=(-e "$tempdir/wrapper") ? $tarball.".tmp" : $tarball;
	doit("xdelta", "patch", "$tempdir/delta", "$tempdir/gentarball", $out);

	if (-e "$tempdir/wrapper") {
		doit("pristine-gz", 
			($verbose ? "-v" : "--no-verbose"),
			($debug ? "-d" : "--no-debug"),
			($keep ? "-k" : "--no-keep"),
			"gengz", "$tempdir/wrapper", $out);
		doit("mv", "-f", $out.".gz", $tarball);
	}
}

sub gendelta {
	my $tarball=shift;
	my $delta=shift;

	my $tempdir=tempdir();
	my @files=qw(delta manifest version type);

	# Check to see if it's compressed.
	open (IN, "<", $tarball) || die "Cannot read $tarball: $!\n";
	my ($chars, $id1, $id2, $method);
	if (read(IN, $chars, 10) == 10 &&
	    (($id1, $id2, $method) = unpack("CCC", $chars)) &&
    	    $id1 == GZIP_ID1 && $id2 == GZIP_ID2 &&
	    $method == GZIP_METHOD_DEFLATE) {
		doit("pristine-gz",
			($verbose ? "-v" : "--no-verbose"),
			($debug ? "-d" : "--no-debug"),
			($keep ? "-k" : "--no-keep"),
			"gendelta", $tarball, "$tempdir/wrapper");
		push @files, "wrapper";
		doit("zcat $tarball > $tempdir/origtarball");
		$tarball="$tempdir/origtarball";
	}
	close IN;
	
	my $sourcedir="$tempdir/tmp";
	doit("mkdir", $sourcedir);
	doit("tar", "xf", File::Spec->rel2abs($tarball), "-C", $sourcedir);
	# if all files were in a subdir, use the subdir as the sourcedir
	my @out=grep { $_ ne "$sourcedir/.." && $_ ne "$sourcedir/." }
		(glob("$sourcedir/*"), glob("$sourcedir/.*"));
	if ($#out == 0 && -d $out[0]) {
		$sourcedir=$out[0];
	}

	doit("tar tf $tarball > $tempdir/manifest");
	gentarball($tempdir, $sourcedir, 1);
	my $ret=system("xdelta delta -0 --pristine $tempdir/gentarball $tarball $tempdir/delta") >> 8;
	# xdelta exits 1 on success if there were differences
	if ($ret != 1 && $ret != 0) {
		die "xdelta failed with return code $ret\n";
	}

	open(OUT, ">", "$tempdir/version") || die "$!";
	print OUT "2.0\n";
	close OUT;
	open(OUT, ">", "$tempdir/type") || die "$!";
	print OUT "tar\n";
	close OUT;

	doit("tar", "czf", $delta, "-C", $tempdir, @files);
}

Getopt::Long::Configure("bundling");
if (! GetOptions(
	"v|verbose!" => \$verbose,
	"d|debug!" => \$debug,
	"k|keep!" => \$keep,
   ) || @ARGV != 3) {
	usage();
	exit 1;
}

my $command=shift;
if ($command eq 'gentar') {
	gentar(@ARGV);
}
elsif ($command eq 'gendelta') {
	gendelta(@ARGV);
}
else {
	print STDERR "Unknown subcommand \"$command\"\n";
	usage();
	exit 1;
}
